import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { ExpenseEntity, LimitRange, WalletLimits } from './wallet.entity';
import { Between, Repository } from 'typeorm';
import * as dayjs from 'dayjs';

@Injectable()
export class LimitsService {
  constructor(
    @InjectRepository(WalletLimits)
    private walletLimits: Repository<WalletLimits>,

    @InjectRepository(ExpenseEntity)
    private expenseEntity: Repository<ExpenseEntity>,
  ) {}

  async create(input: Omit<WalletLimits, 'id' | 'isAutoGenerated'>) {
    const existingItem = await this.walletLimits.findOne({
      where: {
        category: input.category,
        type: input.type,
        walletId: input.walletId,
      },
    });

    if (existingItem) {
      const updatedLimit = await this.walletLimits.save({
        ...existingItem,
        ...input,
        isAutoGenerated: existingItem.isAutoGenerated,
      });

      if (input.type === LimitRange.monthly && !existingItem.isAutoGenerated) {
        await this.updateDerivedLimits(input.walletId, input.category, input.amount);
      }

      return updatedLimit;
    }

    const savedLimit = await this.walletLimits.save({
      ...input,
      isAutoGenerated: false,
    });

    if (input.type === LimitRange.monthly) {
      const daysInMonth = dayjs().daysInMonth();

      await this.walletLimits.save({
        category: input.category,
        walletId: input.walletId,
        type: LimitRange.daily,
        amount: input.amount / daysInMonth,
        isAutoGenerated: true,
      });

      await this.walletLimits.save({
        category: input.category,
        walletId: input.walletId,
        type: LimitRange.weekly,
        amount: (input.amount * 7) / daysInMonth,
        isAutoGenerated: true,
      });

      await this.walletLimits.save({
        category: input.category,
        walletId: input.walletId,
        type: LimitRange.yearly,
        amount: input.amount * 12,
        isAutoGenerated: true,
      });
    }

    return savedLimit;
  }

  private async updateDerivedLimits(walletId: string, category: string, monthlyAmount: number) {
    const daysInMonth = dayjs().daysInMonth();

    const dailyLimit = await this.walletLimits.findOne({
      where: {
        category,
        walletId,
        type: LimitRange.daily,
        isAutoGenerated: true,
      },
    });

    if (dailyLimit) {
      await this.walletLimits.save({
        ...dailyLimit,
        amount: monthlyAmount / daysInMonth,
      });
    }

    const weeklyLimit = await this.walletLimits.findOne({
      where: {
        category,
        walletId,
        type: LimitRange.weekly,
        isAutoGenerated: true,
      },
    });

    if (weeklyLimit) {
      await this.walletLimits.save({
        ...weeklyLimit,
        amount: (monthlyAmount * 7) / daysInMonth,
      });
    }

    const yearlyLimit = await this.walletLimits.findOne({
      where: {
        category,
        walletId,
        type: LimitRange.yearly,
        isAutoGenerated: true,
      },
    });

    if (yearlyLimit) {
      await this.walletLimits.save({
        ...yearlyLimit,
        amount: monthlyAmount * 12,
      });
    }
  }

  delete(id: string) {
    return this.walletLimits.delete({ id });
  }

  find(id: string) {
    return this.walletLimits.find({ where: { id } });
  }

  findAllWallet(walletId: string, type: LimitRange) {
    return this.walletLimits.find({ where: { walletId, type } });
  }

  async limits(walletId: string, type: LimitRange) {
    const [from, to] = this.range(type);

    const expensesByCategory = await this.expenseEntity
      .createQueryBuilder('exp')
      .select('exp.category', 'category')
      .addSelect('SUM(exp.amount)', 'total')
      .where('exp.walletId = :walletId', { walletId })
      .andWhere('exp.type = :type', { type: 'expense' })
      .andWhere('exp.date > :from AND exp.date < :to', { from, to })
      .groupBy('exp.category')
      .getRawMany();

    const limits = await this.findAllWallet(walletId, type);
    const limitsKeyValue = limits.reduce((prev, curr) => {
      return {
        ...prev,
        [curr.category]: {
          ...curr,
          current: 0,
        },
      };
    }, {});

    expensesByCategory.forEach((expense) => {
      if (limitsKeyValue[expense.category]) {
        limitsKeyValue[expense.category].current = parseFloat(expense.total);
      }
    });

    return Object.values(limitsKeyValue);
  }

  private range(type: LimitRange): [Date, Date] {
    switch (type) {
      case LimitRange.daily:
        return [dayjs().startOf('day').toDate(), dayjs().endOf('day').toDate()];

      case LimitRange.monthly:
        return [dayjs().startOf('month').toDate(), dayjs().endOf('month').toDate()];

      case LimitRange.weekly:
        return [dayjs().startOf('week').toDate(), dayjs().endOf('week').toDate()];

      case LimitRange.yearly:
        return [dayjs().startOf('year').toDate(), dayjs().endOf('year').toDate()];

      default:
        console.log('Invalid type provided');
        return [dayjs().startOf('day').toDate(), dayjs().endOf('day').toDate()];
    }
  }
}
